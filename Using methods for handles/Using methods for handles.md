# Используем методы для "ручек" (using methods for handles).
(примеры из [статьи](https://medium.com/@nathanbcrocker/as-the-pros-do-efficiently-passing-arguments-to-http-handlers-in-go-6b593caa00b8))

❗Cуть методов 1 и 2❗
	Благодаря реализации ServeHTTP как метода структуры
	(можно использовать и http.Handler и http.HandlerFunc)
	обработчик ("ручка") может работать с ее полями и производить внутри себя не только действия с http запросом,
	но и с "зависимостями" - подключаться к db, передавать данные логгеру и т.д..
	Все эти данные становятся частью "состояния" функции обработчика.

- ❗ Внедрение зависимости (в GO) означает передачу объекту (экземпляру структуры) значений его полей (its  instance variables✨).
-  Сам процесс "внедрения зависимостей" означает переход к модели построения проекта как композиции сервисов и клиентов, взаимодействие которых "завязано" на структуры и их поля.

✨ О значении понятия instance variables в GO смотри Dependency injection.md

В пакете Go net/http http.Handler и http.HandlerFunc тесно связаны, но выполняют разные цели при обработке HTTP-запросов.

1️⃣❗http.Handler❗:
Это интерфейс, который определяет один метод: ServeHTTP(ResponseWriter, *Request).
Любой тип, реализующий этот (ServeHTTP) метод, считается http.Handler.
Это позволяет создавать пользовательские типы обработчиков, которые могут хранить ❗состояние❗ или инкапсулировать более сложную логику за пределами простой функции.

    type Handler interface {
        ServeHTTP(ResponseWriter, *Request)
    }

2️⃣❗http.HandlerFunc❗:
Это тип, представляющий собой сигнатуру функции, соответствующей ServeHTTP методу интерфейса http.Handler.

Этот тип специально разработан, чтобы позволить обрабатывать обычные функции как интерфейс http.Handler ,
без явного создания пользовательской структуры и реализации интерфейса.

Тип http.HandlerFunc сам реализует http.Handler интерфейс, предоставляя ServeHTTP метод, который просто вызывает базовую функцию, которую он оборачивает.

    type HandlerFunc func(ResponseWriter, *Request)

    // ServeHTTP calls f(w, r).
    func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
        f(w, r)
    }

По сути:
http.Handler— это контракт (the contract) на обработку HTTP-запросов.
http.HandlerFunc— это удобный адаптер, который позволяет простой функции выполнять этот контракт, упрощая использование простых функций в качестве обработчиков.

Практические выводы:
Если у вас есть простая функция, обрабатывающая запрос, вы можете напрямую использовать http.HandlerFunc

Если вам нужен обработчик с внутренним состоянием или более сложным поведением, вы можете определить пользовательскую структуру, реализующую интерфейс http.Handler.